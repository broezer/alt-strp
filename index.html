<!DOCTYPE html>
<html lang="en">
	<head>
		<title>ALT-STRP</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="./main.css">
		<link rel="stylesheet" href="https://use.typekit.net/mpn4vch.css">


		<style>
			svg {
				display: block;
			}
		</style>
	</head>
	<body>
		<main>
			<header class="main">
				<h1>Welkom op ALT-STRP.</h1> 
				
				Een digitale excursie met gecureereerde projecten die inspelen op mens, technologie en natuur.
				Neem de tijd om alle projecten rustig te bekijken en lees de artikelen. Bespreek met elkaar in de chat de projecten die jullie zien. 
			</header>
			<article>
				<header>
					<h1>Terminal Slam</h1>
					<h2>Squarepusher x Daito Manabe</h2>
				</header>

				<div class="video-wrapper">
					<iframe width="560" height="315" src="https://www.youtube.com/embed/GlhV-OKHecI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
				</div>

				<p>
					In de samenwerking tussen de artiesten Squarepusher en Daito Manabe staat het gebruik van technologie centraal. 
					De video, geregisseerd door Daito Manabe, laat een wereld zien waarin MR, Mixed Reality, kan worden ingezet om het leven van de mens prettiger te maken.
					Als locatie is Shibuya gebruikt, een plek die bekend staat om de vele billboards en neon reclame. 
					Door een MR bril te gebruiken ben jij instaat die billboards en reclames te transformeren naar jouw wens. 
					Daarmee ben je weer in controle van de omgeving waar jij je in begeeft. 
					<br/><br/>
					Lees meer over hoe Squarepusher naar deze technologie kijkt in het artikel van The Japan Times. <br/>
					<a href="https://www.japantimes.co.jp/culture/2020/03/27/music/squarepusher#.XoRR8dMzZHc" target="_blank" rel="noopener">Squarepusher speaks up for a little human kindness | The Japan Times</a></p>
					<br/>
				</p>
				<footer>
					<a href="https://squarepusher.net/" target="_blank" rel="noopener">Squarepusher (Official Site)</a><br/>
					<a href="https://en.wikipedia.org/wiki/Squarepusher" target="_blank" rel="noopener">Squarepusher (Wikipedia)</a><br/>
					<a href="https://www.daito.ws/" target="_blank" rel="noopener">Daito Manabe</a><br/>
					<a href="https://rhizomatiks.com/" target="_blank" rel="noopener">Rhizomatiks</a>

				</footer>
	
			</article>

			<article>
				<header>
					<h1>StyleGAN2</h1>
					<h2>Mario Klingemann</h2>
				</header>

				<div class="video-wrapper">
					<iframe width="560" height="315" src="https://www.youtube.com/embed/A6bo_mIOto0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
				</div>

				<h3>

				</h3>
				<p>
					Zoals je kan zien in de video worden er gezichten <em>gemapped</em> op de muziek door een machine learning algoritme. 
					De muziek krijgt daarmee letterlijk een gezicht. Wat vind jij van de uitwerking? 
				</p>
				<footer>
					<a href="http://quasimondo.com/" target="_blank" rel="noopener">Qausimondo, Mario Klingemann (Official Site)</a><br/>
					<a href="https://twitter.com/quasimondo" target="_blank" rel="noopener">Mario Klingemann (Twitter)</a><br/>
					

				</footer>
	
			</article>

			<article>
				<header>
					<h1>Passifolia</h1>
					<h2>Nicolas Guichard & Béatrice Lartigue – Lab212</h2>
				</header>

				<div class="video-wrapper">
					<iframe title="vimeo-player" src="https://player.vimeo.com/video/392951691" width="640" height="337" frameborder="0" allowfullscreen></iframe>
				</div>

				<h3>

				</h3>
				<p>
					Voor het luxemerk Hermès heeft Lab212 een interatieve lightscape/soundscape gemaakt. Ze hebben hierbij gewerkt met licht, geluid en projectie. 
					De minimale look & feel van installatie vereist wel gedetailleerde technische uitwerking en planning. Door de natuurlijke geluiden vervagen ook de grenzen van artificeel en natuurlijk.
					Er wordt duidelijk gespeeld met het contrast van de leegheid van de ruimte en de rijkheid van de flora en fauna. 
					In de uitwerking worden verschillende systemen aan elkaar gekoppeld, er wordt gebruik gemaakt van Rapsberry Pi's, maar ook van Ableton Live, lichten.
					Een flinke diversiteit aan technologie die toch met elkaar moeten samenwerken om de installatie tot leven te laten brengen.
					<br/><br/>
					Het uitgebreide artikel over de installatie met uitleg over de techniek is te vinden op het online magazine Creative Applications.<br/>
					<a href="https://www.creativeapplications.net/maxmsp/passifolia-lightscape-soundscape/" target="_blank" rel="noopener">Passifolia — Lightscape / Soundscape</a>
				</p>
				<footer>
					<a href="https://www.lab212.org/oeuvres/3:commande/46/Passifolia" target="_blank" rel="noopener">Passifolia (Project Page)</a><br/>
					<a href="http://www.lab212.org/" target="_blank" rel="noopener">LAB212</a><br/>
					

				</footer>
	
			</article>


		</main>


		<script type="module">

			import * as THREE from './js/three.module.js';

			import Stats from './jsm/libs/stats.module.js';

			import { SVGRenderer, SVGObject } from './jsm/renderers/SVGRenderer.js';

			var camera, scene, renderer, stats;

			var mesh, group;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 500;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );

				// QRCODE

				var loader = new THREE.BufferGeometryLoader();
				loader.load( 'models/json/QRCode_buffergeometry.json', function ( geometry ) {

					mesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { vertexColors: true } ) );
					mesh.scale.x = mesh.scale.y = mesh.scale.z = 1.6;
					scene.add( mesh );

				} );

				// CUBES

				var cube = new THREE.BoxBufferGeometry( 100, 100, 100 );

				mesh = new THREE.Mesh( cube, new THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 0.9, transparent: true } ) );
				mesh.position.x = 500;
				mesh.rotation.x = Math.random();
				mesh.rotation.y = Math.random();
				mesh.scale.x = mesh.scale.y = mesh.scale.z = 2;
				scene.add( mesh );

				mesh = new THREE.Mesh( cube, new THREE.MeshBasicMaterial( { color:  0xffffff,  opacity: 0.9, transparent: true } ) );
				mesh.position.x = 500;
				mesh.position.y = 500;
				mesh.rotation.x = Math.random();
				mesh.rotation.y = Math.random();
				mesh.scale.x = mesh.scale.y = mesh.scale.z = 2;
				scene.add( mesh );

				// PLANE

				mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 100, 100 ), new THREE.MeshBasicMaterial( { color:  0xffffff, opacity: 0.5, transparent: true, side: THREE.DoubleSide } ) );
				mesh.position.y = - 500;
				mesh.scale.x = mesh.scale.y = mesh.scale.z = 2;
				scene.add( mesh );

				// CYLINDER

				mesh = new THREE.Mesh( new THREE.CylinderBufferGeometry( 20, 100, 200, 10 ), new THREE.MeshBasicMaterial( { color:  0xffffff, opacity: 0.5, transparent: true } ) );
				mesh.position.x = - 500;
				mesh.rotation.x = - Math.PI / 4;
				mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;
				scene.add( mesh );

				// POLYFIELD

				var geometry = new THREE.BufferGeometry();
				var material = new THREE.MeshBasicMaterial( { vertexColors: true, side: THREE.DoubleSide} );

				var v = new THREE.Vector3();
				var v0 = new THREE.Vector3();
				var v1 = new THREE.Vector3();
				var v2 = new THREE.Vector3();
				var color = new THREE.Color();

				var vertices = [];
				var colors = [];

				for ( var i = 0; i < 50; i ++ ) {

					v.set(
						Math.random() * 1000 - 500,
						Math.random() * 1000 - 500,
						Math.random() * 1000 - 500
					);

					v0.set(
						Math.random() * 100 - 50,
						Math.random() * 100 - 50,
						Math.random() * 100 - 50
					);

					v1.set(
						Math.random() * 100 - 50,
						Math.random() * 100 - 50,
						Math.random() * 100 - 50
					);

					v2.set(
						Math.random() * 100 - 50,
						Math.random() * 100 - 50,
						Math.random() * 100 - 50
					);

					v0.add( v );
					v1.add( v );
					v2.add( v );

					color.setHex(  0xffffff );

					// create a single triangle

					vertices.push( v0.x, v0.y, v0.z );
					vertices.push( v1.x, v1.y, v1.z );
					vertices.push( v2.x, v2.y, v2.z );

					colors.push( color.r, color.g, color.b );
					colors.push( color.r, color.g, color.b );
					colors.push( color.r, color.g, color.b );

				}

				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

				group = new THREE.Mesh( geometry, material );
				group.scale.set( 2, 2, 2 );
				scene.add( group );

				// SPRITES

				for ( var i = 0; i < 50; i ++ ) {

					var material = new THREE.SpriteMaterial( { color: /*Math.random()*/ 0xffffff } );
					var sprite = new THREE.Sprite( material );
					sprite.position.x = Math.random() * 1000 - 500;
					sprite.position.y = Math.random() * 1000 - 500;
					sprite.position.z = Math.random() * 1000 - 500;
					sprite.scale.set( 32, 32, 1 );
					scene.add( sprite );

				}

				// CUSTOM

				var node = document.createElementNS( 'http://www.w3.org/2000/svg', 'circle' );
				node.setAttribute( 'stroke', 'white' );
				node.setAttribute( 'fill', 'transparent' );
				node.setAttribute( 'r', '40' );

				for ( var i = 0; i < 20; i ++ ) {

					var object = new SVGObject( node.cloneNode() );
					object.position.x = Math.random() * 1000 - 500;
					object.position.y = Math.random() * 1000 - 500;
					object.position.z = Math.random() * 1000 - 500;
					scene.add( object );

				}

				// CUSTOM FROM FILE

				var fileLoader = new THREE.FileLoader();
				fileLoader.load( 'models/svg/hexagon.svg', function ( svg ) {

					var node = document.createElementNS( 'http://www.w3.org/2000/svg', 'g' );
					var parser = new DOMParser();
					var doc = parser.parseFromString( svg, 'image/svg+xml' );

					node.appendChild( doc.documentElement );

					var object = new SVGObject( node );
					object.position.x = 500;
					scene.add( object );

				} );

				// LIGHTS

				var ambient = new THREE.AmbientLight( 0xf0f0f0 );
				scene.add( ambient );

				var directional = new THREE.DirectionalLight( 0xf0ffff );
				directional.position.set( - 1, 0.5, 0 );
				scene.add( directional );

				renderer = new SVGRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setQuality( 'low' );
				document.body.appendChild( renderer.domElement );

				stats = new Stats();
				document.body.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				var time = Date.now() * 0.0002;

				camera.position.x = Math.sin( time ) * 1000;
				camera.position.z = Math.cos( time ) * 500;
				camera.lookAt( scene.position );

				group.rotation.x += 0.01;

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>